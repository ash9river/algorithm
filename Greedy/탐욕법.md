## 탐욕법
---
모든 정답 중에서 전체 답이 가장 좋은 것을 고르는 동적 계획법이나 완전 탐색이나 비슷하지만,&nbsp; 
탐욕법은 각 단계마다 가장 좋은 방법만을 선택한다.&nbsp; 
##### 지금의 선택이 앞으로 남은 선택에 어떤 영향을 끼치는 지 고려하지 않음.&nbsp; 
---
#### 탐욕법을 사용하는 경우
---
1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 경우. &nbsp; 
2. 시간적 제약 혹은 공간적 제약으로 최적해를 찾을 수 없는 경우. &nbsp; 
##### 2번의 경우 근사해를 구함.&nbsp; 
&nbsp; 
##### 주로 첫번째 용도로만 사용한다. 근사해를 구하는 경우 그리디 알고리즘보다 더 정확한 알고리즘이 많음.
---
# [백준 1931 회의실 배정](https://www.acmicpc.net/problem/1931)
```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    cin.tie(0);
    ios_base::sync_with_stdio(0);
    int n;
    cin>>n;
    vector<pair<int,int>> v(n);
    int a,b;
    for(int i=0;i<n;i++){
        cin>>a>>b;
        v[i].first=b;
        v[i].second=a;
    }
    sort(v.begin(),v.end());
    a=v[0].first;
    int count=1;
    for(int i=1;i<v.size();++i){
        if(a<=v[i].first&&v[i].second>=a){
            a=v[i].first;
            count++;
        }
    }
    cout<<count;
}
```
#### 문제를 탐욕적으로 해결하기 위해서, 매 선택마다 제일 일찍 끝나는 회의를 선택한다.
---
## 탐욕법의 정당성 증명 : 탐욕적 선택 속성
---
동적 계획법처럼 답의 모든 부분을 고려하지 않더라도 최적회를 구할 수 있음을 증명하고,&nbsp;
단계별로 최적의 선택을 할 경우, 전체 문제의 최적해임을 증명.&nbsp;
경우에 따라 첫번째 선택 이후의 선택은 최적이 아닌 경우도 있음.&nbsp;
그 경우에는 최적 부분 구조(Optiaml substructure)를 증명해야 된다.&nbsp;
##### 부분 문제의 최적해에서 전체 문제의 최적해를 만들어 나가는 것.&nbsp;
이 문제의 경우 가장 빠른 종료 시간이 최적해임을 알 수 있가에 탐욕법을 사용한 것이다.

---
### 탐욕적 알고리즘 레시피
<div>
1. 문제의 답을 나누는 과정을 여러 조각으로 나눈다.
2. 각 조각마다 어떤 우선 순위로 선택을 내려야 할 지 결정한다.&nbsp;
3. 선택시, 두 가지의 속성을 증명한다.&nbsp;
   a) 탐욕적 선택 속성 : 항상 각 단계에서 선택한 답을 포함하는 최적해가 존재함을 증명한다.&nbsp;
                         대게 다른 최적해가 존재함을 가정하고, 그 최적해를 조작해서 그리디 알고리즘이 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보인다.&nbsp;
   b) 최적 부분 구조   : 각 단계에서 항상 최적의 선택을 했을 때, 전체 최적해를 구할 수 있는 지의 여부 증명. (대부분 자명함)&nbsp;
    </div>

   
