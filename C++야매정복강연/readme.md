# 대본
```
p1
안녕하세요 강연을 시작하겠습니다.
알고리즘 동아리 SAL에서 문제 해결을 위한 C++ 야매정복을 도와드립니다.
너무 딱딱하다고 생각할 필요는 없고요, 사람도 적고 그러는데 모르는 점 있으면 바로바로 말해주세요.

p2
먼저 강연자 소개입니다.
SAL 동아리에서는 강연자로 저희 회장님과 제가 강연을 맡았는데요.
저는 전정통 19학번 4학년 강재구입니다. 프론트엔드를 목표로 하고 있습니다.
저희 회장님이 독감에 걸리서, 저만 오게 되었습니다.
긴장을 너무 많이 해서 부족한 점이 있을 수도 있지만, 오늘 하루 잘부탁드리겠습니다. 

p3	
강의 목표입니다.
C++을 모르는 사람도 C++을 편하게 이용할 수 있게 도와드리는 것이고요,
강의의 후반부에는 자료구조와 알고리즘 맛보기을 하겠습니다.
하단에 적혀 있는 것들은 저희가 이번 강의를 통해 알아갈 것들인데요, 
천천히 하나하나 짚어드릴테니 이 강의를 통해서 알아갔으면 좋겠습니다.

p4
먼저 자료구조는 데이터를 저장하고 조직하는 방법이나 구조를 의미합니다.
알고리즘은 어떤 문제를 해결하기 위한 절차나 방법이나 명령어들의 집합입니다.
그냥 단순하게 생각하면 문제를 푸는 방식입니다. 공식이라고 생각하셔도 됩니다.
이 알고리즘 문제를 푸는 것을 PS라고 하고요,
대회같은 곳에서 시간걸고 문제푸는 걸 CP라고 해요. 별거없죠?

p5 
간단하게 알고리즘 대회와 코딩 테스트를 소개하겠습니다. 
사실 코딩테스트에 관심이 많잖아요? 요즘 트렌드는 옛날과 달리 코딩테스트를 어렵게 내지 않습니다. 오히려 구현 관련한 문제가 많죠. 실제 상황과 유사한 기능을 구현하는, 데이터 베이스의 명령문인 SQL문을 작성하는 것도 코딩 테스트에 나옵니다.

반면에 알고리즘 대회는 창의성과 사고력을 많이 요구합니다. 수학적 지식도 많이 필요로 하고요.  

p6
왜 알고리즘 문제를 풀까?
단순히 클론코딩 하는것보다 문제를 풀면서 좀 더 성장할 수 있습니다.
저 같은 경우에는 알고리즘을 풀면서 좀 더 논리적인 사고 능력이 길러지고, 다른 프로젝트라던지 코딩할 때, 논리적인 사고 능력이 도움이 많이 된거같아요.

p7
모든 라이브러리 포함
무의미한, 편한 변수명
나만 알면 돼(?) 주석 없이 작성
자유로운 전역 변수 사용
Etc…


p8
PS, 알고리즘 문제풀이에서는 그럴 필요가 없습니다. 단순히 문제만 잘풀면 됩니다.
bits라는 폴더 안에 있는 stdc++.h라는 헤더를 갖다 쓰는 것만으로 모든 헤더, 라이브러리를 가져다가 쓸 수 있습니다.
변수명, 알아서 아무거나 편한거 abc 다 가져다 쓰셔도 됩니다.
주석, 나만 보면 돼, 역시 쓸 필요 없습니다.
전역변수, 엄청 많이 씁니다. 초기화도 자동으로 0이나 false로 해줘서 엄청 편해요. 엄청 많습니다.
그냥 아무거나 다 해도 됩니다. 그런데 왜 C가 아니라 C++을 하는게 나을까?

p9
C언어만 사용하는 것에 비해 C++ 스타일을 사용하면 코딩 실수를 할 확률이 훨씬 적고, 이미 잘 구현된 여러 함수 및 기능들을 사용할 수 있어요.
 그런데 편한 것도 있지만 사실은 지배적이여서 그런겁니다. 백엔드의 경우 한국에서는 자바스프링이 지배적이라서 컴공과는 전부 자바를 배웁니다. 그런데 사실 외국에서는 자바보다는 자바스크립트도 쓰고 타입스크립트도 쓰고 여러가지 다 씁니다. 근데 한국에서는 어른들의 사정에 의해서 자바가 더 지배적이예요. 편한게 더 좋다 이런거보다 사실 어른의 사정이 있어요.
그래서 저희는 C++을 배워야합니다. 

p10
그럼 C++을 배우기 이전에 C스타일과 C++ 스타일을 비교해보겠습니다. 잘보이나요? 배경 흰색이라 진짜 안보일거같은데 안보이면 말씀해주세요.

C에서는 포인터 씁니다. 헷갈려요. 저도 헷갈립니다.
동적할당 malloc씁니다. 너무너무 귀찮아요 free로 메모리 할당 해제도 해야됩니다. 너무나도 귀찮죠…
C++에서는 참조자를 좀더 라이트하게 사용합니다. 포인터랑 비슷하지만 좀더 직관적이죠? 
동적할당도 간단하게 STL을 사용합니다. 같은 한줄이지만 느낌이 다르죠? 더 복잡한 2차원, 3차원 더 나아가서 11차원 배열도  이런 배열을 비교하면 확실히 C++이 더 간단합니다. 근데 제가 방금 말한 STL이 뭔지 들어본 적은 있는데 잘 모르겠죠? 그거는 있다가 말해드릴게요.

p11
지금 c++로 이루어진 이 코드를 관찰해봅시다. 어떤가요?
첫 번째로 헤더부터 봅시다. 헤더파일 선언문 #include (iostream)
C언어에서는 입출력을 위한 printf 함수와 scanf 함수의 호출을 목적으로 헤더파일 <stdio.h>를 포함 했다면, C++에서는 입출력에 관련된 일을 하기 위해서 #include <iostream> 헤더파일 선언을 추가해야 합니다.

만약에 이 문장을 생략하면 다음과 같은 유형의 에러 메시지를 만나게 됩니다.
“std, cout, endl.. 이게 다 뭡니까?"
즉, std, cout, endl과 같은 것을 사용하려면, iostream이라는 헤더파일 선언문이 추가되어야 합니다. 그런데 iostream이라는 헤더파일 선언문을 보면서 다음과 같이 질문할 수도 있어요.
“C++의 헤더파일에는 확장자가 없나요?"
아닙니다! 헤더파일의 확장자는 C언어와 마찬가지로 . h입니다. 그러나 C++에서는 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하기로 약속되어 있습니다. 그래서 그냥 iostream이고요

두 번째로 변수를 입력받는 std::cin과 >>연산자입니다.
키보드로부터 변수를 입력받습니다. 지금은 단순히 정수를 입력 받고 있습니다.
만약 실수형을 입력받고 싶다? 하면 num 앞의 int double로 바꾸시면 됩니다.

C언어의 scanf 함수와 달리 %d, %f와 같은 서식문자를 이용해서 별도의 출력포맷을 지정하지 않아도 변수의 성격에 따라 적절한 입력이 이뤄집니다.

세 번째로 std::cout와 <<연산자를 봅시다.
왼쪽에 std 떙떙 씨 아웃 그리고 왼쪽 쉬프트 출력대상 
출력대상의 위치에는 무엇이든 을 수 있다. 정수와 실수를 비롯해서 문자열, 그리고 변수도 올 수 있습니다.
그리고 C언어의 printf 함수와 달리 %d, %f와 같은 서식문자를 이용해서 별도의 출력포맷을 지정하지 않아도 데이터의 성격에 따라 적절한 출력이 이뤄집니다. 때문에 위의 출력방식은 C인어의 출력방식보다 편리합니다.

네 번째로 왼쪽쉬프트 두 번을 이용한 출력대상을 연이어 출력하고 endl로 개행합니다.

반대로 생각하면 입력 대상도 연이어 받을 수 있겠죠? 그건 한번 혼자서 해보시고, 다음으로 넘어갈게요?

p12
c에서 c++로 가면서 함수의 기능이 확장되었습니다. 그것이 함수 오버로딩입니다.
c에서는 동일한 이름의 함수를 정의하는 것이 허용되지 않았지만, C++에서는 인자에 따라서 함수의 호출을 달리할 수 있습니다. 이를 함수의 오버로딩이라고 합니다. 그 이유가 뭘까요?
c에서는 함수의 이름만을 가지고 호출 대상을 찾지만, c++은 함수의 이름과 매개변수의 선언을 보고 호출 대상을 찾기 때문에 일어나는 결과입니다. 그런데, 이름이랑 매개변수 선언이 같지만, 함수의 반환형이 다르면 어떻게 될까요? 결국 컴파일러는 함수의 호출 대상을 찾지 못하고 결국 컴파일 오류로 이어집니다.

p13
이름공간은 다소 생소한 개념일겁니다.
프로젝트가 대형화되면서 이름의 충돌 문제가 발생했고, 그걸 해결하기 위한 c++의 방안이라 할 수 있습니다. 단순히 특정 영역에 이름을 붙여주는 겁니다. 일단 예시를 볼까요?
오른쪽을 보실래요? 여기에 네임스페이스가 있고요, 함수잇고요 ::이 있는데요, 이건 범위지정 연산자라고 하고요, 이름공간을 지정할 때 사용하는 연산자입니다.
범위 지정 연산자를 통해서 특정 네임스페이스의 함수를 호출하고 있죠?
마이스페이스에서는 마이스페이스 출력하고잇고
your스페이스에서는 your스페이스를 출력하고 있습니다.
지금 이름공간에는 함수만 있지만, 변수도 추가할 수 있습니다.
그리고 그 변수를 한번 출력해보세요.

다 잘되셨으면, 문법적 규칙을 어느 정도 파악할 수 있을겁니다.

p14
C++은 모든 표준 요소를 std 이름 공간에 만들어 둡니다. 그래서 std::cin, std::cout 등등을 사용하는 것입니다.

namespace::요소라고 간단히 생각하시면 됩니다.

근데 cout, cin, endl을 참조할 때마다, std::을 붙여야 하는 이유를 알게되었습니다. 근데 너무 귀찮잖아요? 그래서 using을 사용해 이름공간을 생략할 수 있습니다.
using namespace std; 이름공간 std에 선언된 모든 것들에 대해서 이름 공간 지정의 생략입니다.
그래서 우리가 보통 C++ 코드를 보면 파일 맨 상단에 헤더 파일 include 하고 그다음 using namespace std; 를 볼 수 있는 것입니다.

p15
아까 나왔던 코드랑 차이를 생각해보세요. 엄청 간편해졌죠?
using은 namespace의 영역의 객체를 명시하지 않아도 사용할 수 있게 하는 키워드입니다
디폴트로 std 이름 공간을 사용한다고 생각하시면 편합니다.

p16
전역변수 지정자로서의 ::입니다.
c에서는 지역변수와 전역변수가 같으면 그 지역 변수 범위 내에서는 전역변수를 호출할 수 없었습니다. 하지만 c++은 다릅니다.

지금 보시는대로 전역변수로서 val에 100을 할당하고, main함수의 지역변수로서 똑같은 이름 val에 200을 할당하고, 그대로 200이 출력됩니다. 그런데,  ::으로 전역변수 지정하면 전역변수 val이 출력되어서 100이 출력됩니다. 한번 해보실래요?


p17
논리적인 의미의 참과 거짓을 표현하는 bool 자료형입니다. 참과 거짓을 표현하기 위해 true와 false를 사용합니다. 단순하죠?
그런데 true와 false는 각각 1과 0을 의미하는 키워드이다라고 오해를 하는 경우가 많은데,
 사실 true와 false 단지 참과 거짓을 표현하기 위한 1바이트 크기 데이터입니다.
물론, 이전에 참을 표현하기 위해 숫자 1, 거짓을 표현하기 위해 숫자 0을 사용해서, 지금도 true와 false를 출력하면 각각 1이랑 0이 출력되지만, 한번 따라해볼까요?

p18
참조자입니다. 사실 참조자라는게 포인터와 많이 유사한 개념이지만, 포인터보다는 좀 더 이해하기 쉬운 개념입니다.
지금 코드를 보시면 num1이라는 변수가 있죠?
그런데 그 다음줄에 int에 &(앤)이라는게 달려있죠? 이게 참조자입니다. 참조자는 메모리 공간에 다른 닉네임을 붙이는거라 생각하시면 됩니다. 그래서 지금 num1이라는 int형 메모리공간에 num2라는 이름을 붙여서 num2를 출력하는 명령을 하면 num1이 출력되는것과 마찬가지죠.
이렇듯이 참조자는 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름입니다.
이런 참조자도 제한이 있는데요
선언할 때, 무조건 다른 변수를 참조해야합니다. 



p19
C++로 문제를 풀 때 본인이 자료구조를 하나하나 만들어서 사용하는 것은 시간적으로 굉장히 비효율적입니다.
1/123을 소숫점 5자리까지 계산하라 문제가 나왔는데, 남들 다 공학용 계산기로 문제 푸는데 나만 손으로 계산할 순 없잖아요?
간단하게 말해 이런 것들을 담은 친구들을 STL이라고 합니다.

이 STL은 4가지 구성요소로 이루어져있는데,  이 친구들이 그 주인공들입니다.
Container는 보통 우리가 흔히 듣던 자료구조입니다. 배열인 vector, 큐, 스택 등이 해당됩니다.

그 다음은 Iterator.  반복자라고 합니다. 주로 컨테이너를 탐색, 순회 할 때, 자주 사용되는 인터페이스입니다.
여기서 순회라는 단어가 생소할 수 있는데, 간단히 말하면 자료구조의 모든 원소를 차례대로 방문한다고 생각하시면 됩니다.

Algorithm은 Algorithm이라는 헤더 파일에 정의되어 있는데요, 컨테이너를 다루기 위한 여러 수단을 제공합니다. 정렬 함수 같은 것들이 여기에 쓰입니다.

제일 마지막은 함수 객체라고 불리는 건데요. 함수처럼 동작하는 객체를 말합니다. STL의 알고리즘 함수 중에서 함수 인자로, 이 함수 객체를 받아들이는 경우가 있으나, 지금은 복잡하고, 설명하려면 너무 길어지기 때문에 넘어가겠습니다.

p20
STL에서는, 여러가지 형태의 컨테이너를 제공하고 있기에, 프로그래머가 자신의 상황에 적합한 컨테이너를 고를 수 있습니다. 
동적 배열(vector), 큐(queue), 스택(stack), 힙(priority_queue), 링크드 리스트 (list) 등등을 고르시면 됩니다.

한 가지 유의할 사항은 스택(stack), 큐(queue), 우선순위 큐(priority_queue) 들로 이들은 컨테이너 어댑터(container adaptor) 입니다.
얘네들은 다른 컨테이너 클래스들을 상속 받아서 다른 컨테이너 클래스의 객체에 특정한 인터페이스를 제공해줍니다.

얘네들을 통해 원래 컨테이너의 기능을 제한하고, 어댑터가 제공하는 인터페이스를 사용할 수 있게 됩니다.
그래서 stack 에 그냥 int나 double같은 것들도 넣을 수 있지만, deque 에 작용한다면, deque에 stack 이 제공하는 top, pop, push 등의 인터페이스를 사용할 수 있게 되는 것입니다. 좀 말이 어렵죠? 단순히 말해서 짬뽕할 수 있다는거예요.

연관 컨테이너는 시퀀스 컨테이너와는 다르게 키(key) - 값(value) 구조를 가집니다. 다시 말해 특정한 키를 넣으면 이에 대응되는 값을 돌려준다는 것이지요. 근데 조금 복잡해서 시간상 힘들면 다음 시간에 해볼게요.

p21
드디어 STL 처음이 나왔네요. 벡터입니다.
일단 본 다음에 하면서 배워볼까요?
벡터는 그림에 보이는 것처럼 동적 배열입니다. begin()은 주소를 가리킵니다. 아까 앞에서 말한 이터레이터에 해당됩니다.

begin이랑 end 그리고 back이 있는데 그 차이가 나타나고요 이거 말고도 리버스 비긴 등 여러가지 있는데, 나중에 하나씩 써보면서 익혀보세요.

vector 의 임의의 원소에 접근하는 것은 배열처럼 대괄호 를 이용하거나, at 함수를 이용하면 됩니다.
또한 맨 뒤에 원소를 추가하거나 제거하기 위해서는 push_back 혹은 pop_back 함수를 사용하면 됩니다.
다음 그림으로 한번 볼까요?

p22
그림 보시면 3의 길이로 10 20 30이 들어가있습니다. 이 때, push_back함수로 40을 넣으면~~ 보고 설명

vector가 꽉 찬 상태에서 원소를 추가하면(push_back() 실행시) 기존의 메모리 공간에 원소들을 복사하는 것이 아니라,
보통 현재 크기의 2배에 해당하는 더 큰 메모리 공간을 할당하고, 기존의 원소들을 새로운 공간으로 복사한 후 새로운 원소를 추가합니다. 이 과정에서 메모리를 2배나 차지하는 위험이 발생할 수 있습니다.

p23
자 이제 노트북으로 한번 돌려볼까요?
일단 #include<vector> 해주시고요,
처음에 C에서 그냥 배열 선언하듯이 그냥 1차원vector 생성 해보실래요?
하셨으면, 이제 1차원 벡터 초기화 해볼게요.
다음은 2차원 좀 어려울거같은데 한번 생각해보실래요?
2차원 벡터 초기화, 해보실래요?

나머지는 벡터의 접근 방법입니다. 그냥 단순히 배열처럼 접근할 수 있지만, push_back함수와 pop_back함수로 동적으로 원소를 관리할 수 있습니다.

p24
자, 오른쪽에 보이는 것들은 벡터를 사용할 때, 자주 쓰는 메서드입니다. {차례대로 읽기}
근데 여기서 주의점이 있어요. size입니다. unsigned int이므로 만약, 벡터가 비어있으면 주의해야합니다. 0에서 -1을 하면 오버플로우가 나서 2,147어쩌구가 되잖아요? 그래서 보통 .empty()로 먼저 체크하는 편이 좋아요.

자, 이제 벡터 배열의 크기 조종인데요, 리사이즈 함수를 이용해서 벡터 크기를 마음대로 조종할수 있습니다.

간단하게 백준2738번 한번 같이 풀어볼까요??

p25
이번엔 특별한 방법들이예요.
중복 원소를 제거하는 방법이고, algorithm 헤더를 include해보실래요?


여기까지만할게요

p26
아까 봤던 것처럼 vector는 뒤에 원소를 추가할 시에 메모리를 2배 추가해서, 메모리도 많이 잡아먹고, 연산 시간까지 연이어서 많이 소요될 있습니다.

반면에 deque의 경우에는 그냥 새로운 블록을 할당한 후에 새로운 원소를 넣습니다. 
그림처럼 블록으로 사용한다고 생각하시면 됩니다.
따라서 deque는 메모리를 블록단위로 지정하여 효율적으로 사용하기 때문에, 맨 처음과 끝에 원소를 추가하는 작업을 많이 수행할 때 deque를 사용하는게 낫습니다.

즉, deque는 앞뒤에서 원소를 추가하거나 제거하는 작업에 최적화되어있습니다.

그런데 보통 문제에서 범위가 주어지기 때문에, 고정 배열을 많이 사용해서 deque를 웬만한 문제에선 잘 쓰지 않지만요.
```
