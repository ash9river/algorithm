# 2차원 벡터 계산을 쉽게 만들어 주는 구조체
---
##### 벡터의 직접 구현
```
const double PI=2.0*acos(0.0);
struct vector2{
    double x,y;
    // 생성자를 explicit으로 지정해서 실수가 들어가는 일을 방지
    explicit vector2(double x_=0,double y_=0) : x(x_),y(y_){}
    // 두 벡터의 비교
    bool operator==(const vector2& rhs) const{
        return x==rhs.x&&y==rhs.y;
    }
    bool operator<(const vector2& rhs) const{
        return x!=rhs.x? x<rhs.x:y<rhs.y;
    }
    // 벡터의 덧셈과 뺄셈
    vector2 operator+(const vector2& rhs) const{
        return vector2(x+rhs.x,y+rhs.y);
    }
    vector2 operator-(const vector2& rhs) const{
        return vector2(x-rhs.x,y-rhs.y);
    }
    // 벡터의 실수배
    vector2 operator*(double rhs) const{
        return vector2(x*rhs,y*rhs);
    }
    // 벡터의 크기
    double norm()const{ return hypot(x,y);}
    // 단위 벡터 (영벡터는 정의되지 않음)
    vector2 normalize() const{
        return vector2(x/norm(),y/norm());
    }
    // x축의 양의 방향으로부터 이 벡터까지 반시계 방향 각도 
    double polar() const{return fmod(atan2(y,x)+2*PI,2*PI);}
    // 벡터의 내적
    double dot(const vector2& rhs) const{
        return x*rhs.x+y*rhs.y;
    }
    // 벡터의 외적
    double cross(const vector2& rhs) const{
        return x*rhs.y-y*rhs.x;
    }
    // 벡터의 정사영
    vector2 project(const vector2& rhs) const{
        vector2 r= rhs.normalize();
        return r*r.dot(*this);
    }
    // a가 b보다 p에 얼마나 더 가까운가
    double howMuchCloser(const vector2& p,const vector2& a,const vector2& b){
        return (b-p).norm()-(a-p).norm();
    }
    // 두 벡터의 각도(평행이면 0 반환) 
    double ccw(const vector2& a,const vector2& b){
        return a.cross(b);
    }
    // 세 점의 ccw
    // 점 p를 기준으로 b가 반시계 방향이면 양수, 시계방향이면 음수, 평행이면 0
    double ccw(const vector2& p,const vector2& a,const vector2& b){
        return ccw(a-p,b-p);
    }
};
```
